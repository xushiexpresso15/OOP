"""
agent.py - 智慧交通號誌控制 Agent (Volume-Based Control)

注意事項 (Notes for Developers):
1. 這個檔案是用來實作 Agent 的邏輯。
2. 使用者執行 `py main.py agent <size> [vehicle_count]` 時，主程式會呼叫這裡的 `step` 函式。
3. 您可以通過 `env` 參數與環境互動。
"""

import random

# Module-level state to store timing info for each intersection
# Key: intersection_position (tuple), Value: dict of state info
intersection_controllers = {}

# Parameters
MIN_GREEN_TIME = 5   # Minimum green light duration (seconds)
MAX_GREEN_TIME = 30  # Maximum green light duration (seconds)
TIME_PER_CAR = 3     # Seconds added per waiting vehicle

def get_waiting_counts(env, intersection_pos):
    """
    Count vehicles waiting at the intersection.
    Returns: (ns_count, ew_count)
    """
    ix, iy = intersection_pos
    ns_count = 0
    ew_count = 0
    
    # Get all vehicles
    vehicles = env.get_vehicle_states()
    
    # Check 4 adjacent cells for waiting cars
    # Note: In this grid env, cars wait at the cell *before* entering the intersection
    # intersection_pos is (x, y)
    
    for v in vehicles:
        vx, vy = v['position']
        v_dir = v['direction'] # 'north', 'south', 'east', 'west'
        
        # NS Traffic (Vehicles on Y-axis approaching intersection)
        # From North (y-1) facing South
        if vx == ix and vy == iy - 1 and v_dir == 'south':
            ns_count += 1
        # From South (y+1) facing North
        elif vx == ix and vy == iy + 1 and v_dir == 'north':
            ns_count += 1
            
        # EW Traffic (Vehicles on X-axis approaching intersection)
        # From West (x-1) facing East
        elif vy == iy and vx == ix - 1 and v_dir == 'east':
            ew_count += 1
        # From East (x+1) facing West
        elif vy == iy and vx == ix + 1 and v_dir == 'west':
            ew_count += 1
            
    return ns_count, ew_count

def calculate_duration(car_count):
    """Calculate green light duration based on car count."""
    duration = MIN_GREEN_TIME + (car_count * TIME_PER_CAR)
    return min(MAX_GREEN_TIME, duration)

def step(env):
    """
    Agent 的決策邏輯
    
    這個函式會在每個模擬步驟被呼叫一次。
    """
    global intersection_controllers
    
    # 1. 觀察環境 - 取得所有路口狀態
    intersections = env.get_intersection_states()
    
    for state in intersections:
        pos = state['position']
        
        # Initialize controller state if new
        if pos not in intersection_controllers:
            # Determine current phase from env state or default to NS
            current_phase = 'ns' if state['ns_state'] == 'green' else 'ew'
            intersection_controllers[pos] = {
                'phase': current_phase, # 'ns' or 'ew'
                'time_remaining': 0     # Will force immediate calculation
            }
        
        controller = intersection_controllers[pos]
        
        # Decrement timer
        controller['time_remaining'] -= 1
        
        # Check if phase switch is needed (Timer expired)
        if controller['time_remaining'] <= 0:
            # Get car counts to decide next duration
            ns_count, ew_count = get_waiting_counts(env, pos)
            
            # Switch phase
            if controller['phase'] == 'ns':
                controller['phase'] = 'ew'
                # Calculate time for EW based on EW traffic
                duration = calculate_duration(ew_count)
            else:
                controller['phase'] = 'ns'
                # Calculate time for NS based on NS traffic
                duration = calculate_duration(ns_count)
            
            controller['time_remaining'] = duration
            
            # Debug output (optional)
            # print(f"[Agent] Int {pos}: Switch to {controller['phase'].upper()} for {duration}s (Cars: NS={ns_count}, EW={ew_count})")

        # Apply control
        # We enforce the state every step to override the environment's default timer
        if controller['phase'] == 'ns':
            env.control_intersection(pos, 'ns_green')
        else:
            env.control_intersection(pos, 'ew_green')

    # 3. 重要：必須手動更新紅綠燈計時器
    env.update_intersections()
